1.为什么少用反射
    #不能使用JIT，性能下降。
反射的类型是动态解析的，这将导致JVM无法实施某些特定的优化(具体来说，就是我们常说的JIT优化)，在性能敏感和频繁调用的方法上，应该尽量避免使用反射。
为了提高热点代码的执行效率，在运行时，虚拟机将会把这些代码编译成与本地平台相关的机器码，并进行各种层次的优化，完成这个任务的编译器称为即时编译器（Just In Time Compiler），简称 JIT 编译器。之所以不一次性全部编译，是因为有一些代码只运行一次，没必要编译，直接解释运行就可以。如果编译成机器码那岂不是和 C、C++差不多了，不能跨平台“一次编译，到处运行”。
2.主键和唯一索引的区别
   #本质、包含关系、空值、外键、唯一性
   主键是一种约束，唯一索引是一种索引，两者在本质上是不同的。主键创建后一定包含一个唯一性索引，唯一性索引并不一定就是主键。唯一性索引列允许空值，而主键列不允许为空值。主键列在创建时，已经默认为空值 + 唯一索引了。主键可以被其他表引用为外键，而唯一索引不能。一个表最多只能创建一个主键，但可以创建多个唯一索引。主键更适合那些不容易更改的唯一标识，如自动递增列、身份证号等。在 RBO 模式下，主键的执行计划优先级要高于唯一索引。 两者可以提高查询的速度。
外键：表的外键是另一表的主键, 外键可以有重复的, 可以是空值，一个表可以有多个外键。主表的外键可以重复，副标的外键引用的主键非空不唯一。
当一个表有两个主键时，此时是两个主键一起做为主键，即联合主键，两个主键只要有一个不同，就算作不同的。
3.同步和阻塞的区别
对于同步调用来说，很多时候当前线程还是激活的，只是从逻辑上当前函数没有返回,它还会抢占cpu去执行其他逻辑，也会主动检测io是否准备好。同步，就是在发出一个功能调用时，在没有得到结果之前，该调用就不返回。也就是必须一件一件事做,等前一件做完了才能做下一件事。阻塞调用是指调用结果返回之前，当前线程会被挂起（线程进入非可执行状态，在这个状态下，cpu不会给线程分配时间片，即线程暂停运行）。
在non-blocking IO中，虽然进程大部分时间都不会被block，但是它仍然要求进程去主动的check，并且当数据准备完成以后，也需要进程主动的再次调用recvfrom来将数据拷贝到用户内存。而asynchronous IO则完全不同。它就像是用户进程将整个IO操作交给了他人（kernel）完成，然后他人做完后发信号通知。在此期间，用户进程不需要去检查IO操作的状态，也不需要主动的去拷贝数据。
4.并发和并行的区别
    并发（任务执行时分复用）。并行（相对于串行）是单位时间多个任务同时执行。

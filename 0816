一面：
1.进程和线程以及它们之间的区别
   a.进程是程序的一次执行过程，一个进程可由多个线程组成。线程与进程类似，它是进程更小粒度的划分，线程才是操作系统调度的单位。
   b.每个进程都有自己独立的内存（一般不共享内存）。同一进程内的多个线程共享进程的堆和方法区，每个线程有自己独立的程序计数器、虚拟机栈和本地方法栈。

2. 进程间的通信方式和对应的同步方式，你用过吗？具体怎么用？
   进程间通信
   a.套接字、共享内存、消息队列、管道、信号、信号量、文件。
线程间通信
   a.同步机制、共享内存。

   进程（线程）同步机制
   a.互斥量Mutex。采用互斥对象机制，不仅能实现进程同步，而且能实现同一进程的线程和不同进程的线程的同步。
b.信号量Semaphore。它允许多个线程在同一时刻访问同一资源，但是要限制防问此资源的最大线程数目。信号量S是一个整数，S大于等于0时代表可供并发进程使用的实体数，S小于0时表示正在等待使用共享资源的进程数。
线程同步机制
c.临界区Criical Section。将多线程串行化，在任意时刻只允许一个线程进入临界区访问资源。
d.事件Event。使用等待通知操作使得线程同步。

3.TCP和UDP区别
a.字节、数据报。面向连接、无连接。可靠、不可靠。点对点、一对多。

4. TCP如何保证传输的可靠性？
a.流量控制，拥塞控制，CRC校验，重传ARQ。

5. TCP的拥塞控制，具体过程是怎么样的？UDP有拥塞控制吗？如何解决？
     a.UDP没有拥塞控制。给报文加序号，有丢失序列的报文，则要对网络进行拥塞控制。

二面：
1. 你知道redis有哪几种数据类型吗？你比较熟悉哪几种？为什么？
2. 讲讲redis里面的哈希表吧
3. 一个URL从浏览器输入到响应页面，整个过程是怎么样的，能讲得多详细就讲多详细。
缓存解析DNS：浏览器、系统（host文件）、路由器缓存。
DNS服务器：根域名服务器，顶级域名服务器，主域名服务器。
TCP：HTTP请求，基于TCP的，TCP三次握手。
HTTP  request和response，处理数据。
渲染页面。



浏览器缓存就是把一个已经请求过的Web资源（如html，图片，js）拷贝一份副本储存在浏览器中。缓存会根据进来的请求保存输出内容的副本。当下一个请求来到的时候，如果是相同的URL，缓存会根据缓存机制决定是直接使用副本响应访问请求，还是向源服务器再次发送请求（当然还有304的情况）。
缓存是根据url来处理的，只要url不一样就是新的资源。
浏览器缓存可以分为两种模式，强缓存和协商缓存。强缓存（无HTTP请求，无需协商）
直接读取本地缓存，无需跟服务端发送请求确认。协商缓存（有HTTP请求，需协商）
浏览器虽然发现了本地有该资源的缓存，但是不确定是否是最新的，于是想服务器询问，若服务器认为浏览器的缓存版本还可用，那么便会返回304（Not Modified） http状态码。

Cookie也是一种服务器主动放在浏览器的缓存（key-value形式，内容由服务器code决定），主要解决HTTP是无状态的协议。多个有联系的HTTP请求发生时，需要用cookie来节约访问该站点的时间和提供一些特定的服务。
Session用于记录S和B之间的会话，通过SessionID（B第一次请求建立）实现，SessionID用于标志一次会话。
4. 你说HTTP可以进行多路复用，具体是怎么复用？如果服务器挂掉或者客户端挂掉，会怎么样？
HTTP/2 的多路复用（并行处理request和response）是基于流的，B/S基于一个TCP连接，通过流（最小单位是二进制帧）通信。 HTTP/1.x通过Kee-Alive解决同一域名TCP长连接问题，但仍然存在两个效率低问题（串行文件传输、一个客户端占用多个连接）。
HTTP  B/S挂掉相当于TCP连接异常断掉。暴力异常只能，超时断开。正/异常关闭socket，对端任然发送数据会报10053/10054错误。
5. HTTP的各种头你了解吗？每种头具体是什么作用？说一下
6. 你说arp会进行广播，会造成网络风暴，那应该怎么解决？
7. 你知道CDN吗？说一下
8. BIO NIO AIO说一下？epoll了解吗？用过吗？具体调用OS什么方法？webSocket呢？
    Java 中的 BIO、NIO和 AIO 理解为是 Java 语言对操作系统的各种 IO 模型的封装。程序员在使用这些 API 的时候，不需要关心操作系统层面的知识，也不需要根据不同操作系统编写不同的代码。只需要使用Java的API就可以了。

同步与异步
同步： 同步就是发起一个调用后，被调用者未处理完请求之前，调用不返回。
异步： 异步就是发起一个调用后，立刻得到被调用者的回应表示已接收到请求，但是被调用者并没有返回结果，此时我们可以处理其他的请求，被调用者通常依靠事件，回调等机制来通知调用者其返回结果。
同步和异步的区别最大在于异步的话调用者不需要等待处理结果，被调用者会通过回调等机制来通知调用者其返回结果。
阻塞和非阻塞
阻塞： 阻塞就是发起一个请求，调用者一直等待请求结果返回，也就是当前线程会被挂起，无法从事其他任务，只有当条件就绪才能继续。
非阻塞： 非阻塞就是发起一个请求，调用者不用一直等着结果返回，可以先去干其他事情。
举个生活中简单的例子，你妈妈让你烧水，小时候你比较笨啊，在那里傻等着水开（同步阻塞）。等你稍微再长大一点，你知道每次烧水的空隙可以去干点其他事，然后只需要时不时来看看水开了没有（同步非阻塞）。后来，你们家用上了水开了会发出声音的壶，这样你就只需要听到响声后就知道水开了，在这期间你可以随便干自己的事情，你需要去倒水了（异步非阻塞）。

BIO (Blocking I/O)
同步阻塞I/O模式，数据的读取写入必须阻塞在一个线程内等待其完成。
NIO 简介
NIO是一种同步非阻塞的I/O模型，在Java 1.4 中引入了NIO框架，对应 java.nio 包，提供了 Channel , Selector，Buffer等抽象。
AIO 是异步IO的缩写，AIO 的应用还不是很广泛，Netty 之前也尝试使用过 AIO，不过又放弃了。
9.创建进程调用的是OS哪些方法？具体说说
我们聊聊JAVA吧，你了解JVM吗？给我讲讲
JVM具体会在什么时候进行垃圾回收？JMM具体说说？
垃圾回收算法具体说说？各种垃圾回收器了解吗？什么时候执行STOP THE WORLD？

三面
1. 现在我要求设计一个容器，容器满的时候生产者阻塞，容器空的时候消费者阻塞。

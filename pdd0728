package littlecase.pingduoduo;

import java.util.Scanner;
//输入两个数组A、B，仅仅改变A中的一个元素，就能使得A数组是严格递增的
//在数组B中找出能替换这个元素的数字的最大值，并输出替换后严格增长的数组A。若无则输出NO
public class Solution_2 {
    public static void main(String[] args) {
        Scanner scanner = new Scanner(System.in);
        String a = scanner.nextLine();
        String b = scanner.nextLine();
        String[]  c = a.split(" ");
        String[]  d = b.split(" ");
        int[] e = new int[c.length];
        int[] f = new int[d.length];
        for(int i=0;i<e.length;++i){
            e[i] = Integer.parseInt(c[i]);
        }
        for(int i=0; i<f.length; ++i){
            f[i] = Integer.parseInt(d[i]);
        }

        int index = -1;
        for(int i=0; i<e.length - 1; ++i){
            if(e[i]>e[i+1])
                index = i;
        }

        int max = Integer.MIN_VALUE;

        for(int i=0; i<f.length; ++i){
            if(index == 0){
                if(e[1]>f[i])
                    max = Math.max(max,f[i]);
            }else {
                if(e[index-1] < f[i] && f[i]<e[index+1] )
                    max = Math.max(max,f[i]);
            }

        }

        if (max == Integer.MIN_VALUE){
            System.out.println("NO");
        }else {
            e[index] = max;
            for(int i : e){
                System.out.print(i);
            }
        }
     }
}




package littlecase.tencent;

import java.util.Scanner;
/*
        小Q定义了一种数列称为翻转数列:
        给定整数n和m, 满足n能被2m整除。对于一串连续递增整数数列1, 2, 3, 4..., 每隔m个符号翻转一次, 最初符号为'-';。
        例如n = 8, m = 2, 数列就是: -1, -2, +3, +4, -5, -6, +7, +8.
        而n = 4, m = 1, 数列就是: -1, +2, -3, + 4.
        小Q现在希望你能帮他算算前n项和为多少。
                输入描述:
                输入包括两个整数n和m(2 <= n <= 109, 1 <= m), 并且满足n能被2m整除。
*/


/*
思路: 单纯数学规律，从第一个数字开始，每 2m 个数字之和为 m^2，总共有 n/2m 个这样的组合，因此和为 m*n/2
*/
public class Solution {
    public static void main(String[] args){
        Scanner sc = new Scanner(System.in);
        long n = sc.nextLong();
        long m = sc.nextLong();
        System.out.println(process(n, m));
    }
    public static long process(long n, long m){
        if(n % (2* m) != 0)
            return -1;
        return m * (n / 2);
    }
}
